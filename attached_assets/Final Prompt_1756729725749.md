## MyTypist Backend Development Prompt

This prompt contains everything required to build the complete backend for MyTypist—a production-ready document automation SaaS for Nigerian businesses. It covers all technical, business, and security requirements, and provides clear instructions for seamless future React frontend integration.

---

### 1. Project Overview
MyTypist is a document automation platform enabling users to generate professional documents from templates with placeholder detection and replacement. The system supports pay-as-you-go and subscription models, batch processing, secure payments, and robust admin controls.

---

### 2. Core Requirements
- **Performance:** Sub-500ms for 5 documents, <50ms API responses
- **Security:** Prevent trial abuse, secure wallet system, protected template previews
- **Business Model:** Pay-as-you-go (₦300/doc) and subscription tiers (₦5,500/₦12,000/month)
- **Stack:** FastAPI + SQLite (WAL, optimized) + Redis + Celery

---

### 3. Architecture & Tech Stack
- **FastAPI** (async, modular)
- **SQLAlchemy** (async, database-agnostic)
- **SQLite** (WAL mode, optimized, clear migration path to PostgreSQL)
- **Redis** (caching, sessions)
- **Celery** (background tasks, batch processing)
- **JWT** (authentication, rotation, expiration)
- **Pydantic** (validation)
- **Paystack** (payment integration)

---

### 4. Database Schema
Expand the basic schema to include:
- Users, Templates, Documents, Signatures, Visits
- Subscriptions/Plans
- User Balances
- Transactions
- Template Categories
- Document Generation History
- User Sessions
- Admin Settings
- Audit Trails
- Bulk Processing Support

Sample Table Additions:
```sql
CREATE TABLE subscriptions (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	user_id INTEGER NOT NULL,
	plan_type TEXT NOT NULL, -- 'pay_as_go', 'monthly_5500', 'monthly_12000'
	status TEXT NOT NULL DEFAULT 'active',
	credits_remaining INTEGER DEFAULT 0,
	expires_at TIMESTAMP,
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE user_balances (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	user_id INTEGER UNIQUE NOT NULL,
	balance_naira INTEGER DEFAULT 0,
	type_credits INTEGER DEFAULT 0,
	last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	FOREIGN KEY (user_id) REFERENCES users(id)
);

CREATE TABLE transactions (
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	user_id INTEGER NOT NULL,
	type TEXT NOT NULL, -- 'credit', 'debit', 'document_creation'
	amount_naira INTEGER NOT NULL,
	description TEXT,
	reference_id TEXT, -- Paystack reference
	status TEXT NOT NULL DEFAULT 'pending',
	created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
	FOREIGN KEY (user_id) REFERENCES users(id)
);
```

---

### 5. Security Framework
- JWT authentication with rotation and expiration
- Rate limiting on all endpoints
- Input sanitization and validation
- Encrypted file storage for sensitive documents
- Audit logging for all user actions
- Device fingerprinting/IP tracking for free trial abuse prevention
- Watermarked template previews (diagonal text and/or semi-transparent logo)

---

### 6. Payment & Subscription System
 Flutterwave (Rave) integration (webhook handling, PCI DSS compliance)
 Wallet system with atomic balance management
 Subscription lifecycle management
 Transaction logging and refund/dispute handling
 Free trial tracking (device/phone/IP)

---

### 7. Document Processing Pipeline
- Template upload and placeholder extraction
- Dynamic smart form generation (auto-save, draft system, validation)
- Batch document creation (bulk processing, progress tracking)
- Signature placeholder embedding
- Watermarked previews for anti-theft
- File storage (local for MVP, cloud-ready for future)

---

### 8. Admin Controls
- Template upload and management
- Dynamic pricing and bonus/referral settings
- Audit and usage tracking
- Admin dashboard APIs

---

### 9. Performance Optimization
- SQLite WAL mode, proper indexing
- Redis caching for templates and sessions
- Async processing with Celery
- Database connection pooling
- File streaming for large documents

---

### 10. API Design & Documentation
- RESTful endpoints for all core workflows
- OpenAPI/Swagger documentation
- Clear separation of concerns (auth, payments, documents, admin)
- Error handling and consistent response formats

---

### 11. Frontend Integration Instructions (React)
 Expose all endpoints via OpenAPI docs
 Use JWT for authentication (token refresh/expiration strategies)
 Provide clear API contracts for smart forms, document generation, payments, and admin features
 Enable CORS for frontend domain
 Document all endpoints in `api&connection.md` for frontend team
 Ensure all backend responses are JSON and include error codes/messages
 Provide sample API calls and payloads for each major workflow
 Update payment and subscription forms to POST to `/pay` and `/subscribe` endpoints, sending required payloads for Flutterwave (Rave) integration.

---

### 12. Implementation Steps
1. Set up FastAPI project structure (modular, scalable)
2. Implement enhanced database schema with SQLAlchemy (async)
3. Integrate Redis for caching and sessions
4. Build authentication system (JWT, password reset, role-based permissions)
5. Develop payment system (Flutterwave (Rave), wallet, subscriptions, transactions)
6. Implement document processing pipeline (template upload, smart forms, batch creation)
7. Add admin controls and dashboard APIs
8. Integrate security features (rate limiting, audit logging, anti-theft)
9. Optimize performance (WAL mode, indexing, async tasks)
10. Write comprehensive API documentation and integration guides

---

### 13. Testing & Deployment
- Unit and integration tests for all modules
- Load testing for performance targets
- Security audits and penetration testing
- Deployment scripts for Hetzner CPX11 (or chosen infrastructure)
- Backup and monitoring strategies

---

### 14. Deliverables
- Complete FastAPI backend codebase
- Enhanced database schema and migration scripts
- API documentation (`api&connection.md`)
- Security implementation guide (`Info.md`)
- Frontend integration guide (`Scripts&Optimize.md`)
- Admin and business logic notes (`Note.md`)

---

### 15. Final Notes
Design the backend to be database-agnostic for easy migration to PostgreSQL. Ensure modularity, scalability, and security from day one. Provide clear, well-documented APIs for seamless React frontend integration. All business logic, security, and performance requirements must be met for a public SaaS launch.

---

**Ready to build the complete backend infrastructure for MyTypist.**
---

### 16. Advanced Backend Strategies & Optimizations

- **In-Memory Template Caching:** Store most-used templates in memory (dict) for ultra-fast access; batch load top 10 by usage, update cache on admin actions.
- **Batch Processing:** Support bulk document generation with streaming responses (BytesIO) for both docx and pdf, minimizing disk I/O and maximizing throughput.
- **Signature Extraction:** Implement robust signature extraction using Pillow—allow users to draw/upload, auto-crop, and resize signatures for embedding. Admin can set extraction/cropping rules.
- **Async ORM:** For high concurrency, consider direct async database drivers (e.g., asyncpg for PostgreSQL) and optimize SQLite with PRAGMA settings (WAL, journal_mode=MEMORY, synchronous=OFF).
- **Rate Limiting:** Apply per-IP and per-user rate limits on document generation endpoints to prevent abuse and ensure fair usage.
- **Streaming API Responses:** Use FastAPI StreamingResponse for document downloads, enabling direct memory streaming and reducing latency.
- **Admin Template Marketplace:** Allow both admin and users to upload templates, with moderation and categorization. Templates are indexed and cached for fast retrieval.
- **Error Monitoring:** Integrate Sentry for real-time error tracking and alerting.

---

### 17. CDN, DNS, and Deployment Best Practices

- **Frontend CDN:** Serve React build via Bunny.net or Vercel/Netlify for global asset delivery. Use hashed filenames for cache busting.
- **Cloudflare DNS:** Proxy all domains through Cloudflare for SSL, DDoS protection, and DNS management. Separate API (api.mytypist.net) and frontend (mytypist.net/cdn.mytypist.net) for security and scalability.
- **Backend Hosting:** Deploy FastAPI backend on Hetzner CPX11. Use Nginx as a reverse proxy for API requests, enable HTTPS via Let’s Encrypt.
- **Environment Variables:** Use .env files for all secrets and configuration (API keys, DB URLs, Paystack keys).
- **CORS Configuration:** Explicitly allow frontend domains in FastAPI CORS middleware for secure cross-origin requests.
- **Monitoring:** Track bandwidth, API performance, and error rates using Cloudflare, Bunny.net, and Sentry dashboards.

---

### 18. Collaboration & Real-Time Features

- **Real-Time Editing:** Plan for future WebSocket or Server-Sent Events support for collaborative editing and live updates.
- **Version Control:** Implement document versioning and rollback capabilities for audit and recovery.
- **Comments & Annotations:** Enable inline comments and feedback within documents for team collaboration.

---

### 19. Accessibility, UX, and Support

- **WCAG Compliance:** Ensure frontend and backend APIs support accessibility standards (screen readers, keyboard navigation).
- **User Tutorials:** Provide in-app guides and onboarding flows for new users.
- **Support Channels:** Integrate live chat and comprehensive documentation/FAQ for user support.

---

### 20. Deployment & Scaling Scenarios

- **Frontend on Vercel/Netlify:** Zero load on backend server, instant global scaling, automated builds/deployments.
- **Hybrid Approach:** Frontend on Netlify, backend on Hetzner CPX11, Cloudflare for DNS/CDN, Bunny.net for static assets. Configure CORS and DNS records for seamless integration.
- **Performance Monitoring:** Use analytics to optimize bundle size, database queries, and cache strategies as user base grows.

---

### 21. Example Advanced API Endpoint (Streaming Doc Generation)
```python
@app.post("/generate")
async def generate(template_id: int = Form(...), signature: UploadFile = File(None), **form_data):
	template = TEMPLATES.get(template_id)
	if not template:
		raise HTTPException(404)
	doc_data = await generate_doc(template, form_data, signature.file if signature else None)
	return StreamingResponse(BytesIO(doc_data), media_type="application/vnd.openxmlformats-officedocument.wordprocessingml.document")
```
---

### 21a. Example Payment & Subscription Endpoints (Flutterwave)
```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import os
import flutterwave

app = FastAPI()
flutterwave.api_key = os.getenv("FLUTTERWAVE_SECRET_KEY")
flutterwave.public_key = os.getenv("FLUTTERWAVE_PUBLIC_KEY")

@app.post("/pay")
async def make_payment(payment: Payment):
	payload = {
		"tx_ref": "TX-REF-123",
		"amount": payment.amount,
		"currency": payment.currency,
		"redirect_url": "http://localhost:8000/callback",
		"payment_options": "card",
		"customer": {
			"email": payment.customer_email,
			"name": payment.customer_name
		}
	}
	response = flutterwave.Charge.card(payload)
	return JSONResponse(content={"message": "Payment successful"}, status_code=200)

@app.post("/subscribe")
async def create_subscription(subscription: Subscription):
	payload = {
		"amount": subscription.amount,
		"currency": subscription.currency,
		"frequency": subscription.frequency,
		"duration": subscription.duration,
		"customer": {
			"email": subscription.customer_email,
			"name": subscription.customer_name
		}
	}
	response = flutterwave.Subscription.create(payload)
	return JSONResponse(content={"message": "Subscription created successfully"}, status_code=200)

@app.post("/webhook")
async def handle_webhook(request: Request):
	event = await request.json()
	if event["event"] == "charge.completed":
		# Update database with payment status
		pass
	return JSONResponse(content={"message": "Webhook received"}, status_code=200)
```

---

### 22. Final Recommendations

- Design for modularity, scalability, and security from day one.
- Document all backend APIs and integration flows for frontend developers.
- Optimize for performance at every layer—database, caching, streaming, and deployment.
- Plan for future migration to PostgreSQL and advanced real-time features as user base grows.

---

**This enhanced prompt now incorporates all advanced backend strategies, deployment best practices, and integration details from your backend documentation.**
---

### 23. Advanced Frontend Integration Requirements

- **UI/UX Principles:** Backend APIs must support atomic design, real-time feedback, and instant error reporting for seamless React integration. All endpoints should provide clear, actionable error messages and support skeleton loading states.
- **Accessibility:** Ensure all API responses and documentation support WCAG 2.1 AA standards (semantic data, alt text, keyboard navigation, ARIA roles). Backend must validate and sanitize inputs to prevent accessibility issues.
- **Performance:** APIs should enable lazy loading, code splitting, and support for CDN asset delivery. All endpoints must meet Core Web Vitals targets (LCP ≤ 2.5s, INP ≤ 100ms, CLS ≤ 0.1).
- **Dynamic Forms & Templating:** Backend must support dynamic field definitions, conditional logic, and repeating sections for real-time form generation and preview. Provide endpoints for template metadata, field types, and live document preview.
- **Signature Canvas:** Support multiple signature input methods (drawn, typed, uploaded). Backend should accept base64-encoded images, font selections, and provide secure storage and retrieval for signatures. Enable real-time rendering and preview via API.
- **Error Handling:** All endpoints must return clear, concise, and empathetic error messages with actionable guidance. Support inline validation and immediate feedback for frontend forms.
- **Workflow Automation & Integrations:** Backend should expose endpoints for workflow automation, conditional logic, and cloud storage integrations (Google Drive, Dropbox). Support webhooks and API triggers for automated notifications and document sharing.
- **Compliance:** Ensure all APIs and data flows support ESIGN, eIDAS, GDPR, HIPAA, and SOC 2 compliance. Provide audit trails, role-based access, and secure authentication (OAuth 2.0, MFA).
- **Testing & Collaboration:** Document all API contracts for Jest/Cypress testing. Enable versioned API specs and support for collaborative editing features (WebSocket/SSE ready).

---

### 24. Frontend-Backend Development Phases Alignment

- **Phase 1:** Backend must support public pages, authentication, and core user features with robust, well-documented endpoints.
- **Phase 2:** Add dynamic template gallery, signature canvas, admin tools, and advanced security/compliance features.
- **Phase 3:** Finalize with offline support, multi-language APIs, advanced error handling, and full performance/accessibility compliance.

---

### 25. Competitive Advantage & Continuous Improvement

- Backend must enable rapid iteration, user-centric design, and continuous improvement based on analytics and user feedback. Support flexible pricing, instant document previews, and secure payment flows to address market pain points.

---

**This prompt now fully supports MyTypist’s advanced frontend requirements, ensuring seamless integration, compliance, and a world-class user experience.**
---

### 26. Advanced Architecture & In-Memory Optimizations

- **Microservices:** Structure backend as modular services for document processing, user management, payments, and integrations. Use FastAPI for RESTful APIs and event-driven workflows with Redis and Celery.
- **In-Memory Templates:** Store most-used .docx templates and placeholders in memory (dict) for ultra-fast access, batch load top 10 by usage, and update cache on admin/user actions. Use SQLite for persistence only, with PRAGMA optimizations for speed.
- **Signature Handling:** Support fixed-size PNG/JPG embedding, robust extraction (Pillow), and direct streaming for document generation. Enable users to draw, type, or upload signatures, with admin controls for extraction/cropping.
- **Async Task Processing:** Use Celery for background jobs (batch document creation, email delivery, workflow automation). Optimize for high concurrency and low latency.

---

### 27. CDN, DNS, and Deployment Integration

- **CDN Setup:** Distribute frontend assets via Bunny.net or Cloudflare for global delivery, reduced latency, and offloaded backend traffic. Use hashed filenames for cache busting and automated CI/CD uploads.
- **DNS Management:** Use Cloudflare for DNS, SSL, DDoS protection, and domain proxying. Separate API and frontend domains for security and scalability.
- **Deployment:** Host backend on Hetzner CPX11, use Nginx as reverse proxy, enable HTTPS via Let’s Encrypt. Provide .env configuration for all secrets and keys.

---

### 28. Continuous Improvement, Monitoring, and Support

- **Monitoring:** Integrate Sentry for real-time error tracking, Cloudflare/Bunny.net for bandwidth and performance analytics. Schedule monthly releases and collect user feedback via surveys.
- **Support:** Provide comprehensive user guides, FAQ, and in-app chat support. Track performance and alerts for downtime/errors.
- **Accessibility & UX:** Maintain minimalist, responsive design with Tailwind CSS, clear error/success notifications, and in-app tutorials for onboarding.

---

**This prompt now incorporates all advanced architecture, in-memory optimizations, CDN/DNS setup, async processing, and continuous improvement strategies from your project overview.**
---

### 29. Strong Optimization & Implementation Techniques

- **Advanced Placeholder Extraction:** Implement robust regex-based extraction for placeholders (e.g., ${name}), supporting multi-run, bold, italic, underline, and casing detection. Ensure accurate mapping of placeholders to document structure for reliable replacement.
- **Dynamic Formatting:** Support context-aware formatting (ordinal dates, address blocks, casing transformations) and font/style inheritance for generated documents. Provide helper functions for date formatting, address parsing, and text casing.
- **Multi-Run Handling:** Accurately handle placeholders spanning multiple runs, clearing and updating all affected runs, and maintaining formatting consistency.
- **Admin/User Flows:** Enable secure template upload, extraction, editing, and management for admins. Allow users to create, preview, and download documents with real-time feedback and error handling.
- **Error Handling & Logging:** Integrate clear, actionable error messages, logging for invalid indices, and robust validation for all user inputs and file operations.
- **File Management:** Use secure file naming, storage, and retrieval for generated documents. Support direct streaming for downloads and previews, minimizing disk I/O and latency.
- **Batch Processing & Streaming:** Optimize for bulk document generation with streaming responses, efficient memory usage, and scalable in-memory operations.

---

**This prompt now includes strong optimization, advanced placeholder handling, robust admin/user flows, and best practices for error handling and file management.**

